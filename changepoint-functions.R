###############################################################################
# simulating outcome sequence
###############################################################################

# NOTE: the data are assumed to be generated by a parametric model 
# where the unknown parameter changes with respect to different regimes.

outcome_simulator <- function(N = 150, k = 1,
                              a = 1, b = 1, c = 1, d = 1){
  
  # change point (break) locations
  if(k == 1) {t_k <- c(1,50,N+1) }
  if(k == 2) {t_k <- c(1,50,100,N+1)}
  
  #priors on parameters
  mu_mean <- invgamma::rinvgamma(1, shape = a, rate = b)
  v_mean <- invgamma::rinvgamma(1, shape = a, rate = b)
  
  states <- c()
  mus <- c()
  sigma_2s <- rep(3, length(1:N))
  y_vals <- c()
  
  for(i in 1:(length(t_k) - 1)) {
    
    # simulating mu value for segment
    mu_k <- rnorm(1, mean = mu_mean, sd = sqrt(v_mean))
    #sigma_2 <- invgamma::rinvgamma(1, shape = c, scale = d)
    
    # generating output segment
    y_new <- rnorm(t_k[i + 1] - t_k[i], mean = mu_k, sd = sqrt(3))

    # saving segment outputs to corresponding vectors
    states <- c(states, rep(i, length(y_new)))
    mus <- c(mus, rep(mu_k, length(y_new)))
    #sigma_2s <- c(sigma_2s, rep(sigma_2, length(y_new)))
    
    y_vals <- c(y_vals, y_new)
  }
  
  df <- data.frame(t = 1:N, y = y_vals,
                   true_mu = mus, true_sigma_2 = sigma_2s,
                   state = states)
  
  return(df)
  
}

###############################################################################
# direchlet prior on the one-ahead transition matrix 
# (just writing this out for myself)
###############################################################################

initial_states_creator <- function(N, K) {
  K_init <- rep(1:K, each = floor(N / K))
  return(K_init)
}

# might fix?
tmatrix <- function(K, alpha_1 = 2, alpha_2 = 1) {
  A <- matrix(0, K, K)
  for (i in 1:(K - 1)){
    alphas <- c(alpha_1/(alpha_1 + alpha_2), alpha_2/(alpha_1 + alpha_2))
    non_zero_probs <- rdirichlet(1, alphas)
    A[i,] <- c(rep(0, i - 1), non_zero_probs, rep(0, K - (i + 1)))
  }
  A[K,K] <- 1
  return(A)
}

###############################################################################
# other parameter priors (just writing this out for myself)
###############################################################################

hyperparameters <- rinvgamma(2,1,1)
mu <- hyperparameters[1]
v2 <- hyperparameters[2]

theta <- c()
y <- c()
N <- 150
for(t in 1:N){
  theta[t] <- rnorm(1, mu, sqrt(v2))
  y[t] <- rnorm(1, theta, sqrt(3))
}

###############################################################################
# Gibbs sampling process
###############################################################################

# (1) sample the current state full conditional (this is what I am really not sure how to do)
# (2) sample from A given rest
# (3) sample theta given y_t, mu, and v^2

# will do this for 5000 iterations, 4 chains (ideally)
# check convergence using trace plots and R-hat etc.
# thin by 50 draws like Ko et al (reduce autocorrelation)
# from remain samples, generate MaP of latent state sequence 
# locate where on the sequence is a change -- these will be the change points
# calculate frequecies of estimated change point counts maybe?


